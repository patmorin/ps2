\documentclass{patmorin}
\listfiles
\usepackage{pat}
\usepackage{paralist}
\usepackage{dsfont}  % for \mathds{A}
\usepackage[utf8x]{inputenc}
\usepackage{skull}
\usepackage{paralist}
\usepackage{graphicx}
\usepackage[noend]{algorithmic}

\usepackage[normalem]{ulem}
\usepackage{cancel}
\usepackage{enumitem}

\usepackage{todonotes}

\usepackage[longnamesfirst,numbers,sort&compress]{natbib}

\newcommand{\Rho}{\mathrm{P}}

% \newcommand{\harpoon}{\overset{\rightharpoonup}}
\newcommand{\qa}{\overset{\rightharpoonup}{\varphi}}
\newcommand{\qb}{\overset{\rightharpoondown}{\varphi}}
\newcommand{\qap}{\overset{\rightharpoonup}{\sigma}}
\newcommand{\qbp}{\overset{\rightharpoondown}{\sigma}}

\usepackage[mathlines]{lineno}
\setlength{\linenumbersep}{2em}
% \linenumbers
% \rightlinenumbers
% \linenumbers
\newcommand*\patchAmsMathEnvironmentForLineno[1]{%
 \expandafter\let\csname old#1\expandafter\endcsname\csname #1\endcsname
 \expandafter\let\csname oldend#1\expandafter\endcsname\csname end#1\endcsname
 \renewenvironment{#1}%
    {\linenomath\csname old#1\endcsname}%
    {\csname oldend#1\endcsname\endlinenomath}}%
\newcommand*\patchBothAmsMathEnvironmentsForLineno[1]{%
 \patchAmsMathEnvironmentForLineno{#1}%
 \patchAmsMathEnvironmentForLineno{#1*}}%
\AtBeginDocument{%
\patchBothAmsMathEnvironmentsForLineno{equation}%
\patchBothAmsMathEnvironmentsForLineno{align}%
\patchBothAmsMathEnvironmentsForLineno{flalign}%
\patchBothAmsMathEnvironmentsForLineno{alignat}%
\patchBothAmsMathEnvironmentsForLineno{gather}%
\patchBothAmsMathEnvironmentsForLineno{multline}%
}


\newcommand{\coloured}[2]{{\color{#1}{#2}}}
\newenvironment{colourblock}[1]{\color{#1}}{}

\newcommand{\condref}[1]{(C\ref{#1})}

% Taken from
% https://tex.stackexchange.com/questions/42726/align-but-show-one-equation-number-at-the-end
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}


\setlength{\parskip}{1ex}


\DeclareMathOperator{\diam}{diam}
\DeclareMathOperator{\tw}{tw}
\DeclareMathOperator{\lca}{lca}

\DeclareMathOperator{\x}{x}
\DeclareMathOperator{\height}{height}
\DeclareMathOperator{\depth}{depth}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\sh}{cbt}
\DeclareMathOperator{\cbt}{cbt}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\dc}{dc}

\title{\MakeUppercase{An Optimal Algorithm for Product Structure in Planar Graphs}\thanks{This research was partly funded by NSERC.}}
\author{%
  Prosenjit Bose\thanks{School of Computer Science, Carleton University}\qquad
  % Vida Dujmović\thanks{Department of Computer Science and Electrical Engineering, University of Ottawa}\qquad
  Pat Morin\footnotemark[1]\qquad
  Saeed Odak\thanks{Department of Computer Science and Electrical Engineering, University of Ottawa}}
    % }

\date{}


\newcommand{\colored}[2]{{\color{#1}#2}}

\usepackage{tabularx}


\begin{document}

% \begin{titlepage}
\maketitle

\begin{abstract}
  The \emph{Product Structure Theorem} for planar graphs (Dujmović et al.\ \emph{JACM}, \textbf{67}(4):22) states that any planar graph is contained in the strong product of a planar $3$-tree, a path, and a $3$-cycle.  We give a simple linear-time algorithm for finding this decomposition as well as several related decompositions.  This improves on the previous $O(n\log n)$ time algorithm (Morin.\ \emph{Algorithmica}, \textbf{85}(5):1544--1558).
\end{abstract}
% \end{titlepage}

% \pagenumbering{roman}
% \tableofcontents
%
% \newpage
% \pagenumbering{arabic}

\section{Introduction}

For two graph $G$ and $X$, the notation $G\subseteq X$ denotes that $G$ is isomorphic to some subgraph of $X$.
% Throughout this paper, $P$ denotes the \emph{one way infinite path}, i.e., the path with vertex set $V(P):=\N$ and edge set $E(P):=\{\{i,i+1\}:i\in\N\}$.
The following \emph{planar product structure theorems} have recently been used as a key tool in resolving a number of longstanding open problems on planar graphs, including queue number \cite{dujmovic.joret.ea:planar}, nonrepetitive chromatic number \cite{dujmovic.esperet.ea:planar}, adjacency labelling \cite{dujmovic.esperet.ea:adjacency}, universal graphs \cite{esperet.joret.ea:sparse}, $p$-centered colouring \cite{debski.felsner.ea:improved}, and vertex ranking \cite{bose.dujmovic.ea:asymptotically}.\footnote{In this paper, we will not be working directly with treewidth or the strong graph product ($\boxtimes$), so we omit their definitions.}

\begin{thm}[\citet{dujmovic.joret.ea:planar, ueckerdt.wood.ea:improved}]\label{meta}
  For any planar graph $G$, there exists:
  \begin{compactenum}[(a)]
    \item \label{three_tree} a planar graph $H$ of treewidth at most $3$ and a path $P$ such that $G\subseteq H\boxtimes P\boxtimes K_3$ \cite{dujmovic.joret.ea:planar};
    \item \label{four_tree} a planar graph $H$ of treewidth at most $4$ and a path $P$ such that $G\subseteq H\boxtimes P\boxtimes K_2$; and
    \item \label{six_tree} a planar graph $H$ of treewidth at most $6$ and a path $P$ such that $G\subseteq H\boxtimes P$ \cite{ueckerdt.wood.ea:improved}.
  \end{compactenum}
\end{thm}

In each of the applications of \cref{meta}, the proofs are constructive and lead to algorithms whose running-time is dominated by the time required to compute the relevant decomposition.  The proofs of each part of \cref{meta} are constructive and lead to $O(n^2)$ time algorithms as observed already by \citet{dujmovic.joret.ea:planar}.  \citet{morin:fast} later showed that there exists an $O(n\log n)$ time algorithm to find the decomposition in \cref{meta}.\ref{three_tree}.  In the current note, we show that there exists a linear time algorithm for finding each of the three decompositions guaranteed by \cref{meta}.  This immediately gives an $O(n)$-time algorithm for each of the following problems on any $n$-vertex planar graph $G$:
\begin{compactitem}
  \item computing an $O(1)$-queue layout of $G$ \cite{dujmovic.joret.ea:planar};
  \item nonrepetitively vertex-colouring $G$ with $O(1)$ colours \cite{dujmovic.esperet.ea:planar};
  \item assigning $(1+o(1))\log n$-bit labels to the vertices of $G$ so that one can determine from the labels of vertices $v$ and $w$ whether or not $v$ and $w$ are adjacent in $G$ \cite{dujmovic.esperet.ea:adjacency};
  \item mapping the vertices of $G$ into a universal graph $U_n$ that has $n^{1+o(1)}$ vertices and edges so that any pair of vertices that are adjacent in $G$ maps to a pair of vertices that are adjacent in $U_n$ \cite{esperet.joret.ea:sparse};
  \item colouring the vertices of $G$ with $O(p^3\log p)$ colours so that each connected subgraph $H$ of $G$ contains a vertex whose colour is unique in $H$ or contains vertices of at least $p+1$ different colours \cite{debski.felsner.ea:improved}; and
  \item colouring the vertices of $G$ with $O(\log n/\log\log\log n)$ integers so that the maximum colour that appears on any path $P$ of length at most $\ell$ appears at exactly one vertex of $P$ (for any fixed $\ell\ge 2$) \cite{bose.dujmovic.ea:asymptotically}.
\end{compactitem}

The remainder of this paper is organized as follows: \cref{prelims} presents some necessary background and notation.  \cref{tripod_decompositions} reviews of the proof of \cref{meta}.\ref{three_tree}.  \cref{algorithm} presents the linear time algorithm for finding the decomposition in \cref{meta}.\ref{three_tree}.  \cref{variants} describes the algorithms for finding the decompositions in \cref{meta}.\ref{four_tree} and \cref{meta}.\ref{six_tree}.

\section{Preliminaries}
\label{prelims}

Throughout this paper we use standard graph theory terminology as used in the textbook by Diestel \cite{diestel:graph}.  All graphs discussed here are simple and finite.  For a graph $G$, $V(G)$ and $E(G)$ denote the vertex and edge sets of $G$, respectively.  We use the terms \emph{vertex} and \emph{node} interchangeably, though we typically refer to the vertices of some primary graph $G$ of interest and refer to the nodes of some auxilliary graph (such as a spanning tree) related to $G$.  We say that a subgraph $G'$ of a graph $G$ \emph{spans} a set $S\subseteq V(G)$ if $S\subseteq V(G')$.


\paragraph*{Quotient Graphs.}

Given a graph $G$ and a partition $\mathcal{P}$ of $V(G)$, the \emph{quotient graph} $G/\mathcal{P}$ is the graph with vertex set $V(G/\mathcal{P}):=\mathcal{P}$ and in which two nodes $X,Y\in V(G/\mathcal{P})$ are adjacent if $G$ contains at least one edge $xy$ with $x\in X$ and $y\in Y$.

\paragraph*{Embeddings, Planar Graphs, and (Near-)Triangulations.}

An \emph{embedding} $\psi$ of a graph $G$ associates each vertex $v$ of $G$ with a point $\psi(v)\in \R^2$ and each edge $vw$ of $G$ with a simple open curve $\psi(vw):(0,1)\to\R^2$ whose endpoints\footnote{The \emph{endpoints} of an open curve $\psi:(0,1)\to\R^2$ are the two points $\lim_{\epsilon\downarrow 0} \psi(\epsilon)$ and $\lim_{\epsilon\downarrow 0}\psi(1-\epsilon)$.} are $\psi(v)$ and $\psi(w)$.  We do not distinguish between such a curve $\psi(vw)$ and the point set $\{\psi(vw)(t):0<t<1\}$.
We let $\psi(V(G)):=\{\psi(v):v\in V(G)\}$, $\psi(E(G)):=\bigcup_{vw\in E(G)} \psi(vw)$, and $\psi(G):=\psi(V(G))\cup\psi(E(G))$.  An embedding $\psi$ of $G$ is \emph{plane} if $\psi(vw)\cap\psi(V(G))=\emptyset$ and $\psi(vw)\cap\psi(xy)=\emptyset$ for each distinct pair of edges $vw,xy\in E(G)$.  A graph $G$ is \emph{planar} if it has a plane embedding. A \emph{triangulation} is an edge-maximal planar graph.

If $\psi$ is a plane embedding of a planar graph $G$, then we call the pair $(G,\psi)$ an \emph{embedded graph} and we will not distinguish between a vertex $v$ of $G$ and the point $\psi(v)$ or between an edge $vw$ of $G$ and the curve $\psi(vw)$.  Similarly, we will not distinguish between $G$ and the  point set $\psi(G)$.  Any cycle in an embedded graph defines a Jordan curve. For such a cycle $C$, $\R^2\setminus C$ has two components, one bounded and the other unbounded. We will refer to the bounded component as the \emph{interior} of $C$ and the unbounded component as the \emph{exterior} of $C$.  If $G$ is an embedded triangulation, then the subgraph of $G$ consisting of all edges and vertices of $G$ contained in the closure of the interior of $C$ is called a \emph{near-triangulation}.

Each component of $\R^2\setminus G$ is a \emph{face} of $G$ and we let $F(G)$ denote the set of faces of $G$.  If $G$ is $2$-connected then, for any face $f\in F(G)$, the set of vertices and edges of $G$ contained in the boundary of $f$ forms a cycle.  We may therefore treat a face $f$ of a $2$-connected graph $G$ as a component of $\R^2\setminus G$ or as the cycle of $G$ on the boundary of $f$, relying on context to distinguish between the two usages.  Note that every embedded graph contains exactly one face---the \emph{outer face}---that is unbounded.

\paragraph*{Duals and Cotrees.}

The \emph{dual} $G^\star$ of an embedded graph $G$ is the graph with vertex set $V(G^\star):=F(G)$ and edge set $E(G^{\star}):=\{fg\in \binom{F(G)}{2}:E(f)\cap E(g)\neq\emptyset\}$.\footnote{For a set $S$, $\binom{S}{2}$ denotes the $\binom{|S|}{2}$-element set $\binom{S}{2}:=\{\{x,y\}:x,y\in S, x\neq y\}$.} If $T$ is a spanning tree of $G$ then the \emph{cotree} $\overline{T}$ of $(G,T)$ is the graph with vertex set $V(\overline{T}) := V(G^\star)$ and edge set $E(\overline{T}) := \{ab \in E(G^\star) : E(a) \cap \E(b) \backslash E(T) \neq \emptyset \}$. It is well known that, if $G$ is connected, then $\overline{T}$ is a spanning tree of $G^\star$.
% $\overline{T}:=G^\star-\{ab\in E(G^*):E(a)\cap E(b)\setminus E(T)\neq\emptyset\}$.

For our purposes, a \emph{binary tree} is a rooted tree of maximum degree $3$ whose root has degree at most $2$ and in which each child $v$ of a node $u$ is either the unique \emph{left child} or the unique \emph{right child} of $u$.  If $G$ is a triangulation  and we root $\overline{T}$ at any face $f_0\in F(G)$ that contains an edge of $T$, then $\overline{T}$ is a binary tree, with the classification of left and right children determined by the embedding of $G$.\footnote{There is a small ambiguity here when $T$ contains two edges of $f_0$, in which case the unique child of $f_0$ in $\overline{T}$ can be treated as the left or right child of $f_0$.}

\paragraph*{Paths and Distances.}

A \emph{path} in $G$ is a (possibly empty) sequence of vertices $v_0,\ldots,v_r$ with the property that $v_{i-1}v_i\in E(G)$, for each $i\in\{1,\ldots,r\}$.  The \emph{endpoints} of a path $v_0,\ldots,v_r$ are the vertices $v_0$ and $v_r$.
% We will treat a path $v_0,\ldots,v_r$ interchangeably with the subgraph of $G$ having vertex set $\{v_0,\ldots,v_r\}$ and edge set $\{v_{i-1}v_i:i\in\{1,\ldots,r\}\}$.
The \emph{length} of a non-empty path $v_0,\ldots,v_r$ is the number, $r$, of edges in the path.
% For two vertices $v$ and $w$ in a connected graph $G$, $\dist_G(v,w)$ denotes the minimum length of a path in $G$ that contains both $v$ and $w$.
% For a non-empty subset $S\subseteq V(G)$, $\dist_G(v,S):=\min\{\dist_G(v,w):w\in S\}$.
%

\paragraph*{Trees, Depth, Ancestors, and Descendants.}

Let $T$ be a tree rooted at a vertex $v_0\in V(T)$.  For any vertex $w\in V(T)$, $P_T(w)$ denotes the path in $T$ from $w$ to $v_0$.  For any $w_0\in V(T)$, any prefix $w_0,\ldots,w_r$ of $P_T(w_0)$ is called an \emph{upward path} in $T$; $w_0$ is the \emph{lower endpoint} of this path and $w_r$ is the \emph{upper endpoint}.  The \emph{$T$-depth} of a node $w\in V(T)$ is the length of the path $P_T(w)$. The second node in $P_T(v)$ (if any) is the \emph{$T$-parent} of $v$.  A vertex $a\in V(T)$ is a \emph{$T$-ancestor} of $w\in V(T)$ if $a\in V(P_T(w))$. If $a$ is a $T$-ancestor of $w$ then $w$ is a \emph{$T$-descendant} of $a$.



\paragraph*{Lowest Common Ancestors}

For any two vertices $v,w\in V(T)$, the \emph{lowest common ancestor} $\lca_T(v,w)$ of $v$ and $w$ is the node $a$ in $P_T(v)\cap P_T(w)$ having maximum $T$-depth.  The \emph{lowest commmon ancestor problem} is a well-studied data structuring problem that asks to preprocess a given $n$-vertex rooted tree so that one can quickly return $\lca_T(v,w)$ for any two nodes $v,w\in V(T)$. A number of optimal solutions to this problem exist that, after $O(n)$ time preprocessing using $O(n)$ space, can answer queries in $O(1)$ time \cite{berman.vishkin:recursive,shieber.vishkin:on,harel.tarjan:fast,alstrup.gavoille.ea:nearest,bender.farach-colton:lca,fischer.heun:theoretical}.  The most recent work in this area includes simple and practical data structures that achieve this optimal performance \cite{alstrup.gavoille.ea:nearest,bender.farach-colton:lca,fischer.heun:theoretical}.

\paragraph*{Reconstructing Binary Tree Models}

Let $T$ be a binary tree and $S \subseteq V(T)$. An upward path $v_0,\ldots,v_r$ in a binary tree $T$ is \emph{S-non-branching} if $v_{i}$ has degree 2 and $v_i \notin S$ for each $i\in\{1,\ldots,r-1\}$. For any binary tree $T$ and set $S \subseteq V(T)$, the \emph{model} $T'$ of $T$ with respect to $S$ is the binary tree obtained by replacing each maximal $S$-non-branching path $v_0,\ldots,v_r$ with the edge $v_0v_r$; if $v_{r-1}$ is the left (respectively, right) child of $v_r$ then $v_0$ becomes the left (respectively, right) child of $v_r$.

% An upward path $v_0,\ldots,v_r$ in a binary tree $T$ is \emph{non-branching} if $v_{i-1}$ is the only child of $v_i$ for each $i\in\{1,\ldots,r-1\}$.  For any binary tree $T$, the \emph{model} $T'$ of $T$ is the binary tree obtained by  replacing each maximal non-branching path $v_0,\ldots,v_r$ with the edge $v_0v_r$; if $v_{r-1}$ is the left (respectively, right) child of $v_r$ then $v_0$ becomes the left (respectively, right) child of $v_r$.

\begin{lem}\label{reconstruction}
  % Given a constant query time lowest common ancestor data structure for a binary tree $T$ and a subset $S:=\{x_1,\ldots,x_d\}$ of nodes in $T$. 
  Let $T$ be a binary tree, let $S\subseteq V(T)$, and let $T_0$ be the minimal subtree of $T$ that spans $S$. Then there exists an algorithm that, given an $O(1)$-query time lowest common ancestor data structure for $T$,  computes the model $T_0'$ of $T_0$ with respect to $S$ in $O(d^2)$ time.
\end{lem}

\begin{proof}
  The proof is by induction on $|S|$.  The base case $|S|=1$ is trivial, since then $T_0'=T_0$ is the tree with one node, which is the unique element in $S$.

  If $|S|\ge 2$, then the first step is to determine the root $r$ of $T_0$, which must also be the root of $T_0'$.  This is easily done by first setting $r:=x_1$ and then repeatedly setting $r:=\lca_{T}(r,x_i)$ for each $i\in\{1,\ldots,d\}$. This step takes $O(d)$ time.

  If $r$ has no left child in $T$, then we can immediately apply induction on $S\setminus\{r\}$ and make the right child of $r$ in $T_0'$ the root of the model obtained by induction.  The case in which $r$ has no right child can be handled similarly. If $r$ has both a left child $r_1$ and a right child $r_2$, then the next step is to partition $S\setminus\{r\}$ into a set $S_1$ of descendants of $r_1$ and a set $S_2$ of descendants of $r_2$.   For each $x\in S\setminus\{r\}$ there are only two possibilities for $\lca_{T}(r_1,x)$
  \begin{compactenum}
    \item If $\lca_{T}(r_1,x)=r_1$ then $x\in S_1$.
    \item If $\lca_{T}(r_1,x)=r$ then $x\in S_2$.
  \end{compactenum}
  Therefore, using $O(d)$ lowest common ancestor queries, we can determine the root $r$ of $T'$ and partition $S\setminus\{r\}$ into sets $S_1$ and $S_2$ that define the left and right subtrees of $r$.  We can now recurse on $S_1$ to obtain a tree with root $r_1'$ and recurse on $S_2$ to obtain a tree with root $r_2'$.  We make $r_1'$ the left child of $r$ and $r_2'$ the right child of $r$ to obtain the model $T_0'$ of $T_0$.  The running-time of this  algorithm obeys the recurrence $T(d)\le O(d)+T(d_1) + T(d_2)$, where $d_1 + d_2 \leq d$ and $d_1, d_2 \leq d-1$.  This recurrence resolves to $T(d)\in O(d^2)$.
\end{proof}

% ($d_1 + d_2 = d$ where $d_1, d_2 > 0$) or ($d_1 + d_2 = d-1$ where $d_1, d_2 \geq 0$)






% \subsection{Nearest Marked Ancestors}
%
% The \emph{nearest marked ancestor problem} is another well-studied data structuring problem that asks to preprocess an $n$-vertex rooted tree $T$ whose nodes are all initially \emph{unmarked} with the exception of the root which is \emph{marked}.  The data structure supports two operations:
% \begin{inparaenum}[(i)]
%     \item \emph{mark} a node $u$ of $T$;
%     \item find the \emph{nearest marked ancestor} of a node $u$ of $T$, i.e., the ancestor of $u$ of maximum depth that is marked.
% \end{inparaenum}
% There exists data structures for this problem that use $O(n)$ space and preprocessing and can perform each of these operations in $O(1)$ time  \cite{X}.  Especially simple and efficient solutions exist when the operations are restricted so that the set of marked nodes always induce a connected subtree of $T$.  In this paper we only require this simple version of the data structure.

\section{Tripod Decompositions}
\label{tripod_decompositions}

Let $G$ be an $n$-vertex triangulation and let $T$ be a spanning tree of $G$. For a face $uvw$ of $G$, a \emph{$(G,T)$-tripod} $Y$ with \emph{crotch} $uvw$ is the vertex set of three disjoint (and each possibly empty) upward paths (the \emph{legs} of $Y$) whose lower endpoints are $u$, $v$, and $w$.  A \emph{$(G,T)$-tripod decomposition} is a partition of $V(G)$ into $(G,T)$-tripods.  \citet{dujmovic.joret.ea:planar} proved the following result:

\begin{thm}\label{tripod_decomposition}
  Let $G$ be a triangulation and $T$ be a spanning tree of $G$.  Then there exists a $(G,T)$-tripod decomposition $\mathcal{Y}$ such that $G/\mathcal{Y}$ has treewidth at most $3$.
\end{thm}

It is straightforward to verify that \cref{tripod_decomposition} implies \cref{meta}.\ref{three_tree} by first triangulating the given graph and then taking $T$ to be a breadth-first spanning tree of the resulting triangulated graph \cite[Observation~35]{dujmovic.joret.ea:planar}.

% \begin{remark}
%   The result of \citett{dujmovic.joret.ea:planar} provides tripods with somewhat more structure.  Every tripod has three legs whose lower endpoints are on a common face of $G$.  It is possible to fix, in advance, an $S$-rooted BFS tree $T$ and produce tripods whose legs are paths in $T$.
% \end{remark}

\subsection{Tripod Decompositions from Face Orderings}
\label{orderings}

We now describe how a $(G,T)$-tripod decompositions can be obtained from a sequence of distinct faces of $G$.  Throughout this section (and for the remainder of the paper):
\begin{compactitem}
   \item $G$ is an embedded triangulation with outer face $f_0$ and
   \item $T$ is a spanning-tree of $G$ rooted at a vertex $v_0\in V(f_0)$.
\end{compactitem}
For any subgraph $f$ of $G$, we define $Y_T(f):=f\cup \bigcup_{v\in V(f)} P_T(v)$.\footnote{In all of our examples, the subgraph $f$ will always be a single edge or single face of $G$.}  In words, $Y_T(f)$ is the subgraph of $G$ that includes all the vertices and edges of $f$ and all the vertices and edges of each path from each vertex of $f$ to the root of $T$.

Let $\mathcal{F}:=f_0,\ldots,f_{r}$ be a sequence of distinct faces of $G$ whose first element is the outer face $f_0$. Let $G_{-1}$ denote the graph with no vertices and, for each $i\in\{0,\ldots,r\}$, define the graph $G_i:=\bigcup_{j=0}^i Y_T(f_j)$ and let $Y_i:=V(G_i)\setminus V(G_{i-1})$.  Let $\mathcal{G_F}:= G_0,\ldots,G_{r}$ and let $\mathcal{Y_F}:=Y_0,\ldots,Y_r$.  

Informally, we require that each of the \emph{legs} of each tripod $Y_i$ have  a \emph{foot} on a different vertex of $G_{i-1}$ and that the tripods $Y_1,\ldots,Y_r$ cover all the vertices and edges of $G$. Formally, we say that the sequence $\mathcal{F}$ is \emph{proper} if, for each $i\in\{1,\ldots,r\}$, and each distinct $v,w\in V(f_i)$, $V(Y_T(v)\cap G_{i-1})\neq V(Y_T(w)\cap G_{i-1})$.  The sequence $\mathcal{F}$ is \emph{complete} for $G$ if $G_r=G$.  Note that, if $\mathcal{F}$ is complete, then $\{Y_0,\ldots,Y_r\}$ is a tripod decomposition of $G$.

From the preceding definitions it follows that, if $\mathcal{F}$ is proper, then  $G_i$ is $2$-connected for each $i\in\{0,\ldots,r\}$.  For any $i\in\{0,\ldots,r\}$, consider any face $f$ of $G_i$, that we now treat as a cycle in $G$. An easy proof by induction shows that, for any $j\in\{0,\ldots,i\}$, the induced graph $f[Y_j]$ is connected. %[a path]
% (The path $f[Y_j]$ is a path that first appears in $G_j$.)
We are interested in keeping the number of tripods in $Y_0,\ldots,Y_i$ that contribute to $V(f)$ as small as possible, which motivates our next definition.

The sequence $\mathcal{F}$ is \emph{good} if the resulting sequence of graphs $\mathcal{G}_\mathcal{F}:=G_0,\ldots,G_r$ and tripods $\mathcal{Y}_\mathcal{F}:=Y_0,\ldots,Y_r$ satisfy the following condition:  For each $i\in\{0,\ldots, r\}$ and each face $f$ of $G_i$,
\[
   |\{\ell\in\{0,\ldots,i\}: V(f)\cap Y_{\ell}\neq\emptyset\}|\le 3 \enspace .
\]
In words, each face of each graph $G_i$ has vertices from at most three tripods of $Y_0,\ldots,Y_i$ on its boundary.  Even more, the vertices of $f$ can be partitioned into at most three paths where the vertices of each path belong to a single tripod. \citet{dujmovic.joret.ea:planar} prove \cref{tripod_decomposition} by proving the next lemma.

% In words, this lemma states that if each face of each graph in $\mathcal{G}_{\mathcal{F}}$ has vertices from at most three tripods on its boundary then $G/\mathcal{Y}_\mathcal{F}$ has treewidth at most $3$.

\begin{lem}\label{face_trick}
  Let $G$ be a triangulation with a vertex $v_0$ on its outer face $f_0$ and let $T$ be a spanning tree of $G$ rooted at $v_0$.  Then there exists a sequence $\mathcal{F}:=f_0,\ldots,f_{r}$ of distinct faces of $G$ that is proper, good, and complete.
\end{lem}

\begin{rem}
  \cref{face_trick} is stated in terms of sequences only for convenience and could be rephrased in terms of partial orders. Indeed, consider the partial order $\prec$ defined as follows:  For each $i\in\{1,\ldots,r\}$ let $f_i'$ be the face of $G_{i-1}$ that contains $f_i$; then $f_\ell\prec f_i$ for each $\ell\in\{0,\ldots,i-1\}$ such that $V(f_i')\cap Y_\ell\neq\emptyset$.  It is straightforward to check that any linearization of this partial order will result in the same tripod decomposition $\mathcal{Y_F}:=\{Y_0,\ldots,Y_{r}\}$.
\end{rem}

\citet{dujmovic.joret.ea:planar} prove \cref{face_trick} by giving a recursive algorithm that constructs the face sequence $\mathcal{F}$.  For a face $f$ of $G_i$, define the set $I_f:=\{\ell\in\{0,\ldots,i\}:V(f)\cap Y_\ell\neq\emptyset\}$.  They begin with the outer face $f_0$ of $G$.  To find the face $f_i$, $i>0$, they consider some face $f\not\in\{f_0,\ldots,f_{i-1}\}$ of $G_{i-1}$ and use Sperner's Lemma to show that there is an appropriate face $f_i$ of $G$ (called a \emph{Sperner triangle}) that is contained in $f$. In particular, $f_i$ is chosen so that the three upward paths in $Y_F(f_i)$ lead back to each of the (at most 3) tripods in $\{Y_j:j\in I_f\}$. See \cref{sperner}.

\begin{figure}
  \begin{center}
    \begin{tabular}{ccc}
      \includegraphics{figs/sperner-1} &
      \includegraphics{figs/sperner-2} &
      \includegraphics{figs/sperner-3} \\
      (a) & (b) & (c)
    \end{tabular}
  \end{center}
  \caption{Each face $f$ in $G_{i-1}$ is bounded by at most three tripods $Y_{a_f}$, $Y_{b_f}$, and $Y_{c_f}$ and the tripod $Y_i$ is chosen so that it connects each of these.}
  \label{sperner}
\end{figure}

This proof leads to a divide-and-conquer algorithm: After finding $f_i$, the algorithm recursively decomposes each of the near-triangulations that are bounded by the at most three new faces in $S_i:=F(G_i)\setminus F(G_{i-1})\setminus \{f_i\}$.  The Sperner triangle $f_i$ can easily be found in time proportional to the number of faces of $G$ in the interior of $f$.  However, because the resulting recursion is not necessarily balanced, a straightforward implementation of this yields an algorithm with $\Theta(n^2)$ worst-case running time.

\citet{morin:fast} later showed that, using an appropriate data structure for $T$, this approach can be implemented in such a way that the resulting algorithm runs in $O(n\log n)$ time.  Essentially, Morin's algorithm works by finding the Sperner triangle $f_i$ in time proportional to the minimum number of faces of $G$ contained in any of the faces in $S_i$.  In the next section, we will show that, by using a lowest common ancestor data structure for the cotree $\overline{T}$ along with \cref{reconstruction}, the Sperner triangle $f_i$ can be found in constant time, yielding an $O(n)$ time algorithm.

By now, our presentation of this material differs somewhat from that in \cite{dujmovic.joret.ea:planar,ueckerdt.wood.ea:improved}.  Therefore, we now pause to explain how \cref{face_trick} implies \cref{tripod_decomposition}.\ref{three_tree}.  To do this, we show that there exists a chordal graph $H$ whose largest clique has size at most $4$ and that contains $G/\mathcal{Y_F}$. We construct the graph $H$ so that for each $i\in\{0,\ldots,r\}$ and each face $f$ of $G_i$, $H$ contains a clique on $\{Y_j:j\in I_f\}$. To accomplish this, for each $i\in\{1,\ldots,r\}$ we let $f$ be the face of $G_{i-1}$ that contains $f_i$ and we form a clique on $\{Y_i\}\cup\{Y_j:j\in I_f\}$.  Inductively, the elements of $\{Y_j:j\in I_f\}$ already form a clique, so this operation is equivalent to attaching $Y_i$ to all the vertices of an existing clique of size at most $3$. Therefore, this results in a chordal graph $H$ whose largest clique has size at most $4$ and therefore $H$ has treewidth at most $3$ \cite{gavril:intersection}.

\section{An $O(n)$-Time Algorithm}
\label{linear_time_algorithm}\label{algorithm}

Refer to \cref{baby_sperner_fig} for an illustration of the following (probably well-known) baby version of Sperner's Lemma:

\begin{figure}
  \begin{center}
    \includegraphics{figs/baby_sperner}
  \end{center}
  \caption{\cref{baby_sperner}}
  \label{baby_sperner_fig}
\end{figure}

\begin{lem}\label{baby_sperner}
  Let $N$ be a near-triangulation with outer face $v_0,\ldots,v_r$ and colour each vertex of $N$ red or blue in such a way that $v_0,\ldots,v_\ell$ are coloured red for some $\ell\in\{0,\ldots,r-1\}$ and $v_{\ell+1},\ldots,v_r$ are coloured blue.  Then there exists a path $w_0,\ldots,w_k$ in $N^\star$ such that
  \begin{compactenum}
    \item $w_0$ is the inner face of $N$ with $v_0v_r$ on its boundary;
    \item $w_k$ is the inner face of $N$ with $v_{\ell}v_{\ell+1}$ on its boundary; and
    \item for each $i\in\{1,\ldots,k\}$, the single edge in $E(w_{i-1})\cap E(w_i)$ has an endpoint of each colour.
  \end{compactenum}
\end{lem}

\begin{proof}
  If $w_0=w_k$, the lemma is immediately true, so assume $w_0\neq w_k$.
  Say that an edge of $N$ is \emph{bichromatic} if one of its endpoints is red and the other is blue.  Any edge that is not bichromatic is \emph{monochromatic}.  The outer face $f_0$ of $N$ has exactly two bichromatic edges $v_0v_r$ and $v_{\ell}v_{\ell+1}$ and any inner face of $N$ has either zero or two bichromatic edges.  Consider the subgraph $H$ of $N^\star$ obtained removing each edge $fg\in E(N^\star)$ such that the edge in $E(f)\cap E(g)$ is monochromatic.  Every vertex in $H$ has degree $0$ or $2$, so each connected component of $H$ is either an isolated vertex or a cycle.  The face $f_0$ has degree $2$ so it is contained in a cycle $C$ of $H$.  The two neighbours of $f_0$ in $H$ are $w_0$ and $w_k$. Therefore $C$ contains a path $w_0,\ldots,w_k$ that satisfies the conditions of the lemma.
\end{proof}

The next lemma, which is the main new insight in this paper, allows us to use \cref{reconstruction} to find Sperner triangles in constant time.

\begin{lem}\label{lca_sperner}
  Let $G$ be a triangulation with a vertex $v_0$ on its outer face $f_0$; let $T$ be a spanning tree of $G$ rooted at $v_0$; let $\overline{T}$ be the cotree of $(G,T)$ rooted at $f_0$; let $f_0,\ldots,f_{i-1}$ be a good proper sequence of faces of $G$ that yields a sequence $\mathcal{G_F}:=G_0,\ldots,G_{i-1}$ of graphs and a sequence $\mathcal{Y_F}:=Y_0,\ldots,Y_{i-1}$ of tripods; let $f\not\in \{f_0,\ldots,f_{i-1}\}$ be a face of $G_{i-1}$, and let $S\subseteq F(G)$ contains exactly the (at most three) faces $g\in F(G)$ such that
  \begin{compactenum}[(i)]
      \item $g$ is contained in the interior of $f$;
      \item $g$ contains an edge $vw\in E(f)$ with $v\in Y_a$ and $w\in Y_b$ for some distinct $a,b\in I_f$.
  \end{compactenum}
  Let $\overline{T}_0$ be the minimal subtree of $\overline{T}$ that spans $S$.  Then, if $S$ is non-empty and $f_i\in V(\overline{T}_0)$ is such that each component of $\overline{T}_0-f_i$ contains at most one element of $S$,
  Then $f_0,\ldots,f_i$ is good.
\end{lem}

\begin{proof}
  Let $N$ be the near-triangulation consisting of all vertices and edges of $G$ contained in the closure of the interior of $f$.  Recall that $I_f:=\{j\in\{0,\ldots,i-1\}: Y_j\cap V(f)\neq\emptyset\}$.  Since $f_0,\ldots,f_{i-1}$ is good, $|I_f|\le 3$.  Since $S$ is non-empty $|I_f|\ge 2$.  For each $j\in I_f$, colour each vertex $v$ of $N$ with the colour $j$ if the first vertex of $P_{T}(v)$ in $V(f)$ is contained in $Y_j$.  Say that an edge or face of $N$ is \emph{monochromatic}, \emph{bichromatic}, or \emph{trichromatic} if it contains vertices of one, two, or three colours, respectively.

  $E(f)$ contains exactly $|I_f|$ bichromatic edges.  Since each element of $S$ is an inner face of $N$ that contains a bichromatic edge of $f$, $|S|\le |I_f|\le 3$.  Let $X$ be the subgraph of $N^\star$ that contains an edge $fg\in E(N^\star)$ if and only if $f$ and $g$ are inner faces of $N$ and the edge in $E(f)\cap E(g)$ is bichromatic.  We claim that $X$ is a subgraph of $\overline{T}$.  In order to show this, we need only argue that each edge $uv$ of $T$ in the interior of $f$ is monochromatic.  Consider any $uv\in E(N)\setminus E(f)$ where $u$ is the $T$-parent of $v$.  If $v\not\in V(f)$ then, by definition, $v$ has the same colour as $u$, so $uv$ is monochromatic. The case where $v\in V(f)$ and $u\not\in V(f)$ can not occur since $v\in V(f)$ implies that $P_T(v)\subseteq G_{i-1}$, but $u\not\in V(G_{i-1})$.  Similarly, the case in which $u\in V(f)$ and $v\in V(f)$ can not occur since this implies that $P_T(v)\subseteq G_{i-1}$, but $uv\not\in E(G_{i-1})$.

  Next we claim that all the elements of $S$ are in a single connected component of $X$.  If $|I_f|=2$, then this follows immediately from \cref{baby_sperner}.  If $|I_f|=3$, then let $\{a,b,c\}:=I_f$ and consider a pair $g_1,g_2\in S$ where (without loss of generality) $g_1$ contains a bichromatic edge of $f$ with colours $a$ and $b$ and $g_2$ contains a bichromatic edge of $f$ with colours $b$ and $c$.  By treating $a$ and $c$ as a single colour we may again apply \cref{baby_sperner} to conclude that $g_1$ and $g_2$ are in the same component of $X$.

  Refer to \cref{lca_sperner_fig}(a).
  Therefore $X$ is a subgraph of $\overline{T}$ that has a component containing all the elements of $S$. Therefore $X$ contains $\overline{T}_0$.  By choice, $\overline{T}_0$ contains a path from $f_i$ to each $g\in S$ and each of these paths is disjoint except for their shared starting location $f_i$. 
  % Since each of these paths is also a path in $X$ and $V(X)$ consists entirely of inner faces of $N$.

  \begin{figure}
    \begin{center}
      \begin{tabular}{ccc}
        \includegraphics{figs/fresh-1} &
        \includegraphics{figs/fresh-2} &
        \includegraphics{figs/fresh-4} \\
        (a) & (b) & (c)
      \end{tabular}
    \end{center}
    \caption{The proof of \cref{lca_sperner}}
    \label{lca_sperner_fig}
  \end{figure}

  Refer to \cref{lca_sperner_fig}(b).
  Now, consider the embedded graph $X_0$ obtained as follows: For each $g\in V(\overline{T}_0)$, place a vertex on the center of each bichromatic edge of $g$ and, if $g$ is trichromatic, then place a vertex in the center of $g$.  Next,
   \begin{compactenum}
    \item add an edge joining the center of each trichromatic triangle to each of the centers of its bichromatic edges; and
    \item add an edge (embedded as a straight line segment) joining the centers of each pair of bichromatic edges that are on a common bichromatic face $g\in V(\overline{T}_0)$.
  \end{compactenum}
  The graph $X_0$ is a tree of maximum-degree $3$ that has $|I_f|$ leaves.  (Each leaf in $X_0$ is the center of a bichromatic edge in $E(f)$).  With the exception of these three leaves, every point in the embedding of $X_0$ is contained in the interior of $f$.

  Refer to \cref{lca_sperner_fig}(c).
  Now treat $X_0$ as a point set and consider the point set $f'$ obtained by removing $X_0$ from the closure of $f$. Now $f'$ has $|I_f|$ connected components and each vertex of $f_i$ is in a different component.  Each of the components of $f'$ contains vertices of $Y_j$ for exactly one $j\in I_f$; call this the \emph{colour} of the component.  Since no edge of $T$ crosses $X_0$, the colour of each vertex in $f_i$ is equal to the colour the component of $f'$ that contains it.

  Finally, to see that $f_0,\ldots,f_i$ is good first observe that we need only be concerned with the at most three faces in $F(G_i)\setminus F(G_{i-1})\setminus\{f_i\}$ and each of these shares a bichromatic edge with $f_i$.  If $g$ is a face in $F(G_i)\setminus F(G_{i-1})\setminus\{f_i\}$ with $E(g) \cap E(f_i) = \{uv\}$ and $uv$ is coloured with $a$ and $b$, then $V(g)\cap Y_j=\emptyset$ for any $j\in\{0,\ldots,i\}\setminus\{a, b, i\}$.  This completes the proof.
  % If $uv$ is a edge of $f_i$ that is coloured with colours $a$ and $b$ and $g$ is a face of $G_i$ that contains $uv$ on its boundary, then $V(g)\cap Y_j=\emptyset$ for any $j\in\{0,\ldots,i\}\setminus\{a, b, i\}$.  This completes the proof.
\end{proof}

%
%
%
% \cref{lca_sperner} implies that, given the triangles $q_1$, $q_2$ and $q_3$, one can use a lowest common ancestor data structure to find, in constant time a constant-size set $S:=\{\lca_{\overline{T}}(g_\alpha,g_\beta):\alpha,\beta\in\{1,2,3\}\}$ of candidate faces, one of which is the Sperner triangle $f_i$.
% This quickly leads to an $O(n)$ time algorithm that, like the algorithm of \citet{morin:fast} uses a nearest marked ancestor data structure on $T$ to recognize which of these candidate faces is the correct choice for $f_i$.
%
% We now show that the nearest marked ancestor data structure can be eliminated entirely. Instead, we can identify the face $f_i\in S$ using only lowest common ancestor queries.  Using the notation from \cref{lca_sperner}, let $C$ be the outer face of $N$ and let $g_1$, $g_2$, and $g_3$ be the inner faces of $N$ having bichromatic edges of $C$ on their boundary where $g_1$ has an edge of $C$ coloured with $a$ and $b$, $g_2$ has an edge of $C$ coloured with $b$ and $c$, and $g_3$ has an edge of $C$ coloured with $a$ and $c$.  There are three cases, illustrated in \cref{lca_cases}.
%
% \begin{figure}
%   \begin{center}
%     \begin{tabular}{ccc}
%       \includegraphics{figs/lca_cases-1} &
%       \includegraphics{figs/lca_cases-2} &
%       \includegraphics{figs/lca_cases-3} \\
%       (1) & (2) & (3)
%     \end{tabular}
%   \end{center}
%   \caption{Identifying a Sperner triangle $f_i$ using lowest common ancestor queries over $g_1$, $g_2$, and $g_3$.}
%   \label{lca_cases}
% \end{figure}
%
% \begin{enumerate}
%   \item If $g_\alpha=g_\beta$ for some distinct $\alpha,\beta\in\{1,2,3\}$  then $g_\alpha$ is trichromatic and we can take $f_i:=g_\alpha$.  In the proof of \cref{lca_sperner}, this corresponds to the case where $f_i$ has an edge of $C$ on its boundary.
%
%   % \item If $\lca_{\mathcal{T}}(g_\alpha,g_\beta)=g_\gamma$ for distinct $\alpha,\beta,\gamma$ then $g_\beta$ is trichromatic and we are done.
%
%   \item If $\lca_{\mathcal{T}}(g_\alpha,g_\beta)=g_\beta$ and $\lca_{\overline{T}}(g_\beta,g_\gamma)=q$ for distinct  $\alpha$, $\beta$, $\gamma$, and $q\ne g_\beta$ then $g_\beta$ is trichromatic and we are done.  Note that this includes the case where $g_\gamma=q$ or $g_\beta=q$.  In the proof of \cref{lca_sperner} this also corresponds to the case where $f_i$ has an edge of $C$ on its boundary.
%
%   \item If $\lca_{T}(g_\alpha,g_\beta)=p$, $\lca_{T}(g_\beta,g_\gamma)=q$,  $\lca_{\overline{T}}(g_\alpha,g_\gamma)=q$, and $\lca_{\overline{T}}(p,q)=q$ for distinct $\alpha$, $\beta$, $\gamma$, $p$, and $q$, then $p$ is trichromatic and we are done. This includes the possibility that  $q=g_\gamma$.  In the proof of \cref{lca_sperner} this corresponds to the case where $f_i$ has no edge of $C$ on its boundary.
% \end{enumerate}
% The preceding cases are exhaustive since, after ruling out Case~1, the minimal subtree of $\overline{T}$ that contains $g_1$, $g_2$, and $g_3$ is a binary tree whose leaves are a subset of $\{g_1,g_2,g_3\}$.  Any binary tree with $n\ge 3$ nodes and at most $3$ leaves has either $2$ leaves (Case~2) or $3$ leaves (Case 3).
%
% \begin{rem}\label{colour_remark}
%   The process described above not only makes it possible to identify $f_i$ in constant time, but also makes it possible to determine the colours of each of the three vertices of $f_i$ in constant time.  This is clearly true for Cases~1 and 2. To handle Case~3, we can use three queries in the lowest common ancestor data structure for $\overline{T}$ to determine the first edge on the path in $\overline{T}$ from $f_i$ to each of $g_1,g_2,g_3$.  For each $j\in\{1,2,3\}$, the colours on $g_j$ are the same as those of the edge of $f_i$ that is dual to the first edge on the path to $g_j$.
% \end{rem}



\begin{thm}\label{three_tree_algorithm}
  There exists an $O(n)$ time algorithm that, given any $n$-vertex triangulation $G$ and any rooted spanning tree $T$ of $G$, produces a $(G,T)$-tripod decomposition $\mathcal{Y}$ such that $\tw(G/\mathcal{Y})\le 3$.
\end{thm}

\begin{proof}
  Let $v_0$ be the root of $T$ and let $f_0$ be a face of $G$ incident to $v_0$ that contains an edge of $T$ incident to $v_0$.  In a preprocessing step, we compute the cotree $\overline{T}$ of $(G,T)$ and construct a lowest common ancestor data structure for $\overline{T}$ in $O(n)$ time that allows us to compute $\lca_{\overline{T}}(f,g)$ for any two faces $f,g\in F(G)$ in $O(1)$ time.

  After this preprocessing, we construct the good sequence $f_0,\ldots,f_{r}$ recursively. Conceptually, during any recursive invocation, the input is a near-triangulation $N$ bounded by a cycle $C$ in $G$ whose vertices belong to at most three tripods computed in previous steps.  Each vertex of $G$ starts initially \emph{unmarked} and we \emph{mark} a vertex once we have placed it in a tripod.  The precise input to a recursive invocation is defined as follows:
  \begin{enumerate}
    \item If $C$ intersects three tripods then the input consists of the three inner faces $g_1$, $g_2$, and $g_3$ of $N$ that contain bichromatic edges of $C$.  \cref{lca_sperner} characterizes the face $f_i$ in terms of the minimum subtree $\overline{T}_0$ of $\overline{T}$ that contains $g_1$, $g_2$, and $g_3$.  Indeed, $f_i$ is either the unique degree-$3$ node of $\overline{T}_0$ (if $g_1$, $g_2$, and $g_3$ are all leaves of $\overline{T}_0$) or $f_i$ is the unique node among $g_1$ $g_2$, or $g_3$ that has degree $2$.  By \cref{reconstruction} we can construct the model $\overline{T}_0'$ of $\overline{T}_0$ in constant time and find the node $f_i$.

    \item If $C$ intersects two tripods, then the input consists of two inner faces $g_1$, $g_2$, of $N$ with bichromatic edges of $C$ on their boundary.  In this case, we let $f_i:=g_1$ or $f_i=g_2$, either choice satisfies our requirements.

    \item If $C$ intersects only one tripod, then the input consists of any inner face $g_1$ of $N$ that contains an edge in $E(f)$.  In this case $f_i:=g_1$ satisfies our requirements.
\end{enumerate}
Once we have found the Sperner triangle $f_i$, we can compute the tripod $Y_i$ and mark its vertices by following the path in $T$ from each vertex of $f_i$ to its nearest marked ancestor in $T$.  This takes $O(1+|Y_i|)$ time.  Once we have done this, we have also found the at most three bichromatic edges of $G_i$ that are needed to perform the at most three recursive invocations on the near triangulations whose outer faces coincide with each of the new faces in $F(G_i)\setminus F(G_{i-1})\setminus\{f_i\}$.

After setting $f_0$, the initial recursive call falls into the third case above, so its input is any of the three inner faces that shares an edge with the outer face, $f_0$.  Each recursive invocation adds a new face $f_i$ to the good face sequence $f_0,\ldots,f_{r}$ and takes $O(1+|Y_i|)$ time.  Since $Y_0,\ldots,Y_{r}$ is a partition of $V(G)$, the running time of this algorithm is therefore $\sum_{i=0}^{r} O(1+|Y_i|) = O(n)$.
\end{proof}


\section{Variations}
\label{variants}

In this section we show that there are $O(n)$ time algorithms for computing the decompositions in \cref{meta}.\ref{four_tree} and \cref{meta}.\ref{six_tree}.  In the same way that \cref{meta}.\ref{three_tree} follows from the tripod decomposition of \cref{tripod_decomposition}, \cref{meta}.\ref{four_tree} follows from a bipod decomposition given by \cref{bipod_decomposition_algorithm} and \cref{meta}.\ref{six_tree} follows from a monopod decomposition given by \cref{monopod_decomposition_algorithm}.

% Both algorithms are based on the fact that lowest common ancestor information is sufficient to reconstruct the shapes of certain subtrees of the cotree $\overline{T}$.



% the following two variations on the product structure theorem also have linear-time algorithms:
% \begin{itemize}
%   \item For every planar graph $G$, there exists a planar graph $H$ of  treewidth at most $6$ and a path $P$ such that $G\subseteq H\boxtimes P$ \cite{ueckerdt.wood.ea:improved}.
%   \item For every planar graph $G$, there exists a planar graph $H$ of treewidth at most $4$ and a path $P$ such that $G\subseteq H\boxtimes P\boxtimes K_2$.
% \end{itemize}
%
% Both of these results are obtained by recursive algorithm similar to that described for computing tripod decompositions.

\subsection{Bipod Decompositions}

We begin with the decomposition in \cref{meta}.\ref{four_tree}, which was communicated to us by Vida~Dujmović, and has not appeared before.  This decomposition is obtained by selecting a proper sequence $\mathcal{E}:=e_0,\ldots,e_k$ of distinct edges of $G$, which define a sequence of graphs $\mathcal{G_E}:=G_{0},\ldots,G_k$ where $G_i:=\bigcup_{j=0}^i P_T(e_j)$ and a sequence of \emph{bipods} $\mathcal{I_E}:=\Lambda_0,\ldots,\Lambda_k$ where $\Lambda_i=V(G_i)\setminus V(G_{i-1})$.  We call $\mathcal{E}$ \emph{good} if, for each $i\in\{0,\ldots,k\}$ and each face $f\in F(G_i)$, $V(f)$ has a non-empty intersection with at most $4$ bipods in $\Lambda_0,\ldots,\Lambda_i$.

Exactly the same argument used in \cref{orderings} to show that $G/\mathcal{Y_F}$ is contained in a chordal graph of maximum clique size $4$ also shows that if $\mathcal{E}$ is a good edge sequence that produces a bipod partition $\mathcal{I_E}$ of $V(G)$, then $G/\mathcal{I_E}$ is contained in a chordal graph of maximum clique size $5$, so $G/\mathcal{I_E}$ has treewidth at most $4$.

We now explain why a good edge sequence $e_0,\ldots,e_r$ exists.\footnote{The existence of this edge sequence is more easily proven using Sperner's Lemma, but we want a proof that lends itself to a linear time algorithm.}  As before, we set $f_0$ to be any face of $G$ such that $E(f_0)$ contains an edge of $T$ incident to the root $v_0$ of $T$.  The edge $e_0$ is any edge of $E(f_0)\setminus E(T)$.  Next we take special care to ensure that $G_i$ is biconnected for $i\ge 1$.  In particular, if $G_0$ contains only two edges of $f_0$, then we take $e_1$ to be the edge of $f_0$ that does not appear in $G_0$.  Otherwise, we choose $e_1$ using the general strategy for choosing $e_i$, described next.

Refer to \cref{e_i}.  Now we may assume that $G_{i-1}$ is biconnected. To choose the edge $e_i$, we consider any face $f\in F(G_{i-1})\setminus F(G)$. Inductively, $V(f)$ contains vertices from at most four bipods in $\Lambda_0,\ldots,\Lambda_{i-1}$. Let $I_f:=\{j\in\{0,\ldots,i-1\}:\Lambda_j\cap V(f)\neq\emptyset\}$. If $|I_f| < 4$ then we can select $e_i$ to be any edge in the interior $f$. Therefore, we focus on the case $|I_f| = 4$. As before we colour vertices in the near triangulation $N$ using colours in the set $I_f$; we let $S$ be the set of inner faces in $N$ that contain a bichromatic edge in $E(f)$; and let $\overline{T}_0$ be the minimal subtree of $\overline{T}$ that spans $S$.  The same argument in the proof of \cref{lca_sperner} shows that every node of $\overline{T}_0$ is contained in $f$.

\cref{director}, below, shows that $\overline{T}_0$ contains an edge $xy$ such that each component of $\overline{T}_0-xy$ contains at most two elements of $S$.  It is straightforward to verify that, if we choose $e_i$ to the be the edge in $E(x)\cap E(y)$ then we obtain a graph $G_i$ in which each of the two new faces containing vertices from $\Lambda_i$ contains vertices from at most three bipods in $\{\Lambda_j:j\in I_f\}$, as required.

\begin{figure}[htbp]
  \begin{center}
    \begin{tabular}{cc}
      % \includegraphics{figs/fourby}
       \includegraphics{figs/two_up-1} &
       \includegraphics{figs/two_up-3}
     \end{tabular}
  \end{center}
  \caption{Choosing the next $e_i$ in a  good edge sequence.}
  \label{e_i}
\end{figure}

\begin{clm}\label{director}
  $\overline{T}_0$ contains an edge $xy$ such that each component of $\overline{T}_0-xy$ contains at most two nodes of $S$.
\end{clm}

\begin{proof}
  Direct each edge $xy$ of $\overline{T}_0$ in the direction $\overrightarrow{xy}$ if the component of $\overline{T}_0-xy$ that contains $y$ contains three or more nodes of $S$.  It is sufficient to show that this process leaves some edge $xy$ of $\overline{T}_0$ undirected.  Assume for the sake of contradiction that every edge of $\overline{T}_0$ is directed.  Then some node $x$ of $\overline{T}_0$ has only incoming edges. Certainly $x$ does not have degree $1$ in $\overline{T}_0$.

  If $x$ has degree $2$ in $\overline{T}_0$ then $\overline{T}_0$ contains two subtrees $T_1$ and $T_2$ that have only the node $x$ in common and such that $|V(T_1)\cap S|\ge 3$ and $|V(T_2)\cap S|\ge 3$, which implies that $|S|\ge 3+3-1 > 4$, a contradiction.

  Suppose therefore that $x$ has degree $3$ in $\overline{T}_0$.  Each face in $S$ contains an edge in $E(f)$, so each face in $S$ has degree at most $2$ in $\overline{T}_0$.  Therefore $x\not\in S$.  Therefore $\overline{T}_0-x$ contains three components $T_1, T_2, T_3$ such that each pair of components contains at least $3$ elements of $S$.  But this implies that $|S|\ge (3\times 3)/2>4$, a contradiction.
\end{proof}



Algorithmically, using \cref{reconstruction}, we can construct the model $\overline{T}_0'$ of $\overline{T}_0$ in constant time given the set $S$.  The model $\overline{T}_0'$ will also contain an edge $\alpha\beta$ such that each component of $\overline{T}_0'-\alpha\beta$ contains at most two nodes in $S$. We claim that $E(\alpha)$  contains an edge that makes a suitable choice for $e_i$, and this edge can be found in constant time.  Indeed, the edge $\alpha\beta$ in  $\overline{T}_0'$ corresponds to a path $\alpha,x_1,\ldots,x_k,\beta$ in $\overline{T}_0$ and the unique edge in $E(\alpha)\cap E(x_1)$ is a suitable choice for $e_i$.  

The rest of the details of the algorithm are similar to those given in the proof of \cref{three_tree_algorithm}:  Each subproblem is a near-triangulation $N$ bounded by a cycle $C$ and the input that defines the subproblem consists of the (at most four) faces $S\subseteq F(N)$ incident to bichromatic edges of $C$.\footnote{In the degenerate case where $C$ has no bichromatic edges, the input is any face of $N$ incident to an edge of $C$.}

\begin{thm}\label{bipod_decomposition_algorithm}
  There exists an $O(n)$ time algorithm that, given any $n$-vertex triangulation $G$ and any rooted spanning tree $T$ of $G$, produces a $(G,T)$-bipod decomposition $\mathcal{I}$ such that $\tw(G/\mathcal{I})\le 4$.
\end{thm}


\subsection{Monopod Decompositions}

Finally we consider the decomposition described in \cref{meta}.\ref{six_tree}.   This decomposition is obtained from a tripod decomposition $\mathcal{Y}:=Y_0,\ldots,Y_r$, obtained by a sequence $\mathcal{F}:=f_0,\ldots,f_r$ of faces of $G$ in the same manner described in \cref{orderings}.  However in this setting, the sequence $f_0,\ldots,f_r$ is \emph{good} if, for each $i\in\{0,\ldots,r\}$ and each face $f$ of $G_i:=\bigcup_{j=0}^i Y_T(f_j)$, $V(f)$ contains vertices from at most $5$ \emph{legs} of tripods in $Y_{0},\ldots,Y_i$.  Under these conditions, \citet{ueckerdt.wood.ea:improved} are able to show that the \emph{monopod decomposition} $\mathcal{I}$ obtained by splitting each tripod $Y_i$ into three upward paths yields a quotient graph $G/\mathcal{I}$ of treewidth at most $6$.

As before we focus on the extreme case when $V(f)$ contains vertices from exactly 5 legs of tripods. Refer to \cref{uwy}. Following the same strategy used for the previous two decompositions, the set $S$ in this case has size at most $5$ and the face $f_i$ corresponds to a node of $\overline{T}_0$ such that each component of $\overline{T}_0-f_i$ contains at most $2$ nodes in $S$.  (This is always possible because $\lfloor 5/2\rfloor=2$.)  Again, a suitable choice for $f_i$ can be found in the model $\overline{T}_0'$ of $\mathcal{T}_0$ in constant time.

\begin{figure}[htbp]
  \begin{center}
    \begin{tabular}{cc}
      % \includegraphics{figs/fourby}
       \includegraphics{figs/uwy2-1} &
       \includegraphics{figs/uwy2-3}
     \end{tabular}
  \end{center}
  \caption{The selection of a tripod by \citet{ueckerdt.wood.ea:improved}}
  \label{uwy}
\end{figure}


\begin{thm}\label{monopod_decomposition_algorithm}
  There exists an $O(n)$ time algorithm that, given any $n$-vertex triangulation $G$ and any rooted spanning tree $T$ of $G$, produces a $(G,T)$-monopod decomposition $\mathcal{I}$ such that $\tw(G/\mathcal{I})\le 6$.
\end{thm}


\section*{Acknowledgement}

This research was initiated at the BIRS 21w5235 Workshop on Graph Product Structure Theory, held November 21--26, 2021 at the Banff International Research Station.  The authors are grateful to the workshop organizers and participants for providing a stimulating research environment.  We are especially grateful to Vida~Dujmović for sharing \cref{meta}.\ref{four_tree} with us.


\bibliographystyle{plainurlnat}
\bibliography{ps2}


\end{document}
